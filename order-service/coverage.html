
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mocks: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/huydq/order-service/app/core/mocks/index.go (100.0%)</option>
				
				<option value="file1">github.com/huydq/order-service/app/core/repository/index.go (0.0%)</option>
				
				<option value="file2">github.com/huydq/order-service/app/core/repository/order.go (92.3%)</option>
				
				<option value="file3">github.com/huydq/order-service/app/core/service/index.go (0.0%)</option>
				
				<option value="file4">github.com/huydq/order-service/app/core/service/order.go (100.0%)</option>
				
				<option value="file5">github.com/huydq/order-service/cmd/http.go (0.0%)</option>
				
				<option value="file6">github.com/huydq/order-service/cmd/root.go (0.0%)</option>
				
				<option value="file7">github.com/huydq/order-service/main.go (0.0%)</option>
				
				<option value="file8">github.com/huydq/order-service/transport/http/handler/index.go (0.0%)</option>
				
				<option value="file9">github.com/huydq/order-service/transport/http/handler/order.go (0.0%)</option>
				
				<option value="file10">github.com/huydq/order-service/transport/http/index.go (0.0%)</option>
				
				<option value="file11">github.com/huydq/order-service/transport/http/server/controller.go (0.0%)</option>
				
				<option value="file12">github.com/huydq/order-service/transport/http/server/route_http.go (0.0%)</option>
				
				<option value="file13">github.com/huydq/order-service/transport/http/wire_gen.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: index.go
//
// Generated by this command:
//
//        mockgen -source=index.go -destination=../mocks/index.go
//

// Package mock_repository is a generated GoMock package.
package mock_repository

import (
        context "context"
        reflect "reflect"

        models "github.com/huydq/order-service/app/core/models"
        gomock "go.uber.org/mock/gomock"
)

// MockIOrderRepository is a mock of IOrderRepository interface.
type MockIOrderRepository struct {
        ctrl     *gomock.Controller
        recorder *MockIOrderRepositoryMockRecorder
        isgomock struct{}
}

// MockIOrderRepositoryMockRecorder is the mock recorder for MockIOrderRepository.
type MockIOrderRepositoryMockRecorder struct {
        mock *MockIOrderRepository
}

// NewMockIOrderRepository creates a new mock instance.
func NewMockIOrderRepository(ctrl *gomock.Controller) *MockIOrderRepository <span class="cov8" title="1">{
        mock := &amp;MockIOrderRepository{ctrl: ctrl}
        mock.recorder = &amp;MockIOrderRepositoryMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIOrderRepository) EXPECT() *MockIOrderRepositoryMockRecorder <span class="cov8" title="1">{
        return m.recorder
}</span>

// CreateOrder mocks base method.
func (m *MockIOrderRepository) CreateOrder(ctx context.Context, orderAgg models.OrderAggregate) (int, error) <span class="cov8" title="1">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "CreateOrder", ctx, orderAgg)
        ret0, _ := ret[0].(int)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// CreateOrder indicates an expected call of CreateOrder.
func (mr *MockIOrderRepositoryMockRecorder) CreateOrder(ctx, orderAgg any) *gomock.Call <span class="cov8" title="1">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateOrder", reflect.TypeOf((*MockIOrderRepository)(nil).CreateOrder), ctx, orderAgg)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package repository

import (
        "context"
        "github.com/google/wire"
        csql "github.com/huydq/gokits/libs/storage/pg-client"
        "github.com/huydq/order-service/app/core/models"
)

//go:generate mockgen -source=index.go -destination=../mocks/index.go

type IOrderRepository interface {
        CreateOrder(ctx context.Context, orderAgg models.OrderAggregate) (int, error)
}

type OrderRepository struct {
        orderClient csql.BasePostgresSqlxDB
}

type OrderPostgresClient struct {
        db csql.BasePostgresSqlxDB
}

func NewOrderPostgresClient(db csql.BasePostgresSqlxDB) *OrderPostgresClient <span class="cov0" title="0">{
        return &amp;OrderPostgresClient{
                db: db,
        }
}</span>

func NewOrderRepository(client OrderPostgresClient) *OrderRepository <span class="cov0" title="0">{
        return &amp;OrderRepository{
                orderClient: client.db,
        }
}</span>

var ProviderSet = wire.NewSet(NewOrderRepository, NewOrderPostgresClient)
</pre>
		
		<pre class="file" id="file2" style="display: none">package repository

import (
        "context"
        "errors"
        "fmt"
        "github.com/gofiber/fiber/v2/log"
        "github.com/huydq/order-service/app/core/models"
        "github.com/huydq/order-service/util"
        "github.com/jmoiron/sqlx"
        "strings"
)

func (o OrderRepository) CreateOrder(ctx context.Context, orderAgg models.OrderAggregate) (int, error) <span class="cov8" title="1">{
        var orderID int
        err := o.orderClient.Transaction(ctx, func(tx context.Context) error </span><span class="cov8" title="1">{
                orderArgs := []interface{}{
                        orderAgg.Order.CustomerID,
                        orderAgg.Order.TotalAmount,
                        util.ORDER_STATUS_PENDING,
                }
                orderQuery := "INSERT INTO orders (customer_id, total_amount, status, created_at, updated_at) VALUES (?, ?, ?, NOW(), NOW()) RETURNING id"
                orderQuery = sqlx.Rebind(sqlx.DOLLAR, orderQuery)
                row := o.orderClient.GetTx(tx).QueryRowxContext(tx, orderQuery, orderArgs...)
                err := row.Scan(&amp;orderID)
                if err != nil </span><span class="cov8" title="1">{
                        log.Errorf("Create order failed", err.Error())
                        return err
                }</span>

                // Prepare batch insert for order items.
                <span class="cov8" title="1">valueStrings := []string{}
                itemValueArgs := []interface{}{}
                // Using 4 columns: order_id, product_id, quantity, price.
                for _, item := range orderAgg.Items </span><span class="cov8" title="1">{
                        valueStrings = append(valueStrings, "(?, ?, ?, ?)")
                        itemValueArgs = append(itemValueArgs, orderID, item.ProductID, item.Quantity, item.Price)
                }</span>

                <span class="cov8" title="1">itemsQuery := fmt.Sprintf("INSERT INTO order_items (order_id, product_id, quantity, price) VALUES %s", strings.Join(valueStrings, ","))
                itemsQuery = sqlx.Rebind(sqlx.DOLLAR, itemsQuery)
                _, err = o.orderClient.GetTx(tx).ExecContext(tx, itemsQuery, itemValueArgs...)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Create order item failed", err.Error())
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Create order failed aggregate", err.Error())
                return 0, errors.New(util.ERR_INTERNAL_SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">return orderID, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "github.com/google/wire"
        "github.com/huydq/order-service/app/core/repository"
)

type OrderService struct {
        orderRepo repository.IOrderRepository
}

func NewOrderService(orderRepo repository.IOrderRepository) OrderService <span class="cov0" title="0">{
        return OrderService{
                orderRepo: orderRepo,
        }
}</span>

var ProviderSet = wire.NewSet(NewOrderService)
</pre>
		
		<pre class="file" id="file4" style="display: none">package service

import (
        "context"
        "errors"
        "github.com/gofiber/fiber/v2/log"
        "github.com/huydq/order-service/app/core/models"
        "github.com/huydq/order-service/util"
        pbOrderMgmt "github.com/huydq/proto/gen-go/order"
)

// CreateOrder handles order creation
func (uc *OrderService) CreateOrder(ctx context.Context, orderDto pbOrderMgmt.CreateOrderRequest) (*pbOrderMgmt.CreateOrderResponse, error) <span class="cov8" title="1">{
        order := models.Order{
                CustomerID: int(orderDto.CustomerId),
        }

        orderItems := make([]models.OrderItem, len(orderDto.Items))
        for i, item := range orderDto.Items </span><span class="cov8" title="1">{
                orderItems[i] = models.OrderItem{
                        ProductID: int(item.ProductId),
                        Quantity:  int(item.Quantity),
                }
        }</span>

        <span class="cov8" title="1">orderAgg := models.OrderAggregate{
                Order: order,
                Items: orderItems,
        }
        orderId, err := uc.orderRepo.CreateOrder(ctx, orderAgg)
        if err != nil </span><span class="cov8" title="1">{
                log.Errorf("Create Order failed", err.Error())
                return nil, errors.New(util.ERR_INTERNAL_SERVER_ERROR)
        }</span>

        <span class="cov8" title="1">return &amp;pbOrderMgmt.CreateOrderResponse{
                OrderId: int32(orderId),
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">/*
Copyright © 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cmd

import (
        "github.com/huydq/order-service/transport/http"
        "github.com/spf13/cobra"
)

// httpCmd represents the http command
var httpCmd = &amp;cobra.Command{
        Use:   "http",
        Short: "A brief description of your command",
        Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                http_server.StartHttpServer()
        }</span>,
}

func init() <span class="cov0" title="0">{
        rootCmd.AddCommand(httpCmd)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">/*
Copyright © 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package cmd

import (
        "os"

        "github.com/spf13/cobra"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &amp;cobra.Command{
        Use:   "order_reservation-service",
        Short: "A brief description of your application",
        Long: `A longer description that spans multiple lines and likely contains
examples and usage of using your application. For example:

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
        // Uncomment the following line if your bare application
        // has an action associated with it:
        // Run: func(cmd *cobra.Command, args []string) { },
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov0" title="0">{
        // Here you will define your flags and configuration settings.
        // Cobra supports persistent flags, which, if defined here,
        // will be global for your application.

        // rootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.order_reservation-service.yaml)")

        // Cobra also supports local flags, which will only run
        // when this action is called directly.
        rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">/*
Copyright © 2025 NAME HERE &lt;EMAIL ADDRESS&gt;
*/
package main

import "github.com/huydq/order-service/cmd"

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package order_handler

import (
        "github.com/google/wire"
        "github.com/huydq/order-service/app/core/service"
)

type OrderHandler struct {
        orderService service.OrderService
}

func NewOrderHandler(orderService service.OrderService) *OrderHandler <span class="cov0" title="0">{
        return &amp;OrderHandler{
                orderService: orderService,
        }
}</span>

var ProviderSet = wire.NewSet(NewOrderHandler)
</pre>
		
		<pre class="file" id="file9" style="display: none">package order_handler

import (
        "github.com/gofiber/fiber/v2"
        pbOrderMgmt "github.com/huydq/proto/gen-go/order"
)

func (h *OrderHandler) CreateOrder(ctx *fiber.Ctx) error <span class="cov0" title="0">{
        var req pbOrderMgmt.CreateOrderRequest
        if err := ctx.BodyParser(&amp;req); err != nil </span><span class="cov0" title="0">{
                return ctx.Status(400).JSON(fiber.Map{"error": "Invalid request"})
        }</span>

        <span class="cov0" title="0">orderRes, err := h.orderService.CreateOrder(ctx.UserContext(), req)
        if err != nil </span><span class="cov0" title="0">{
                return ctx.Status(500).JSON(fiber.Map{"error": err.Error()})
        }</span>

        <span class="cov0" title="0">return ctx.JSON(orderRes)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package http_server

import (
        "flag"
        "github.com/carlmjohnson/versioninfo"
        "github.com/huydq/order-service/app/core/repository"

        "github.com/huydq/gokits/app"
        csql "github.com/huydq/gokits/libs/storage/pg-client"
        credis "github.com/huydq/gokits/libs/storage/redis"
        httpserver "github.com/huydq/gokits/libs/transport/http"
)

// go build -ldflags "-X main.Version=x.y.z"
var (
        // flagconf is the config flag.
        flagconf string
)

func init() <span class="cov0" title="0">{
        flag.StringVar(&amp;flagconf, "conf", "configs/public.yaml", "config path, eg: -conf config.yaml")
}</span>

func StartHttpServer() <span class="cov0" title="0">{
        versioninfo.AddFlag(nil)

        flag.Parse()

        app.InitServer(flagconf) // need to do at first

        httpServer := httpserver.NewHttpServer()

        csql.InstallSQLClientManager()
        credis.InstallRedisClientManager()
        orderPgClient := repository.NewOrderPostgresClient(csql.NewBasePostgresSqlxDB(csql.DB_ORDER_SERVICE))
        if orderPgClient == nil </span><span class="cov0" title="0">{
                panic("Get postgres client failed")</span>
        }
        <span class="cov0" title="0">s, err := wireApp(httpServer, *orderPgClient)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">app.DoInstance(s)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package server

import (
        "github.com/google/wire"
        httpserver "github.com/huydq/gokits/libs/transport/http"
        "github.com/huydq/gokits/shared/core/biz/healthz"
        order_handler "github.com/huydq/order-service/transport/http/handler"
)

type OrderPublicServer struct {
        httpServer *httpserver.HttpServer

        healthz      *healthz.HealthZBiz
        orderHandler *order_handler.OrderHandler
}

func NewOrderPublicServer(
        httpServer *httpserver.HttpServer,
        healthzBiz *healthz.HealthZBiz,
        orderHandler *order_handler.OrderHandler,
) *OrderPublicServer <span class="cov0" title="0">{
        return &amp;OrderPublicServer{
                httpServer:   httpServer,
                healthz:      healthzBiz,
                orderHandler: orderHandler,
        }
}</span>

func (s *OrderPublicServer) Start() <span class="cov0" title="0">{
        s.setupHttpRoute()
        go s.httpServer.Serve()
}</span>

func (s *OrderPublicServer) Stop() <span class="cov0" title="0">{
        s.httpServer.Stop()
}</span>

var ProviderSet = wire.NewSet(NewOrderPublicServer)
</pre>
		
		<pre class="file" id="file12" style="display: none">package server

func (s *OrderPublicServer) setupHttpRoute() <span class="cov0" title="0">{
        apiGroup := s.httpServer.Group("/")
        orderGroup := apiGroup.Group("orders")

        orderGroup.Post("", s.orderHandler.CreateOrder)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package http_server

import (
        "github.com/huydq/gokits/libs/transport/http"
        "github.com/huydq/gokits/shared/core/biz/healthz"
        "github.com/huydq/order-service/app/core/repository"
        "github.com/huydq/order-service/app/core/service"
        "github.com/huydq/order-service/transport/http/handler"
        "github.com/huydq/order-service/transport/http/server"
)

// Injectors from wire.go:

func wireApp(httpServer *httpserver.HttpServer, orderClient repository.OrderPostgresClient) (*server.OrderPublicServer, error) <span class="cov0" title="0">{
        healthZBiz := healthz.NewHealthZBiz(httpServer)
        orderRepository := repository.NewOrderRepository(orderClient)
        orderService := service.NewOrderService(orderRepository)
        orderHandler := order_handler.NewOrderHandler(orderService)
        orderPublicServer := server.NewOrderPublicServer(httpServer, healthZBiz, orderHandler)
        return orderPublicServer, nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
